вся суть здесь заключается в двух syscall-ax: 

1) semtimedop с P <- ожидает изменения состояния семафора
в течение определённого времени, если нет то вырубает прогу
2) SEM_OP с SEM_UNDO. При проставлении данного флага в случае смерти процесса во время критической
секции у нас есть возможность отследить это - если перед крит секцией опустить семафор с этим флагом,
то после смерти значение семафора вернётся к прежнему (до того, как его понизил процесс, использующий
semop с SEM_UNDO). То есть, необходимо сделать отдельные семафоры readyReader и readyWriter, которые 
изначально == 1, после входа в них соотв. программ они опускаются до нуля, а в случае смерти снова
выставятся в единицу.

Алгоритм:

WRITER:
    1) Рождение, создание глобального set-a семафоров (если ещё не создан)
    2) Сначала ожидание пока busy не будет == 0, 
    затем повышение семафора busy на 1 SEM_UNDO, и readyWriter на 1 (в противоп порядке))
теперь если у нас создастся новый writer, то он будет ожидать на этом моменте окончания 
работы предыдущей пары
    3) Делаем P (1) на семафоре readyReader (ждём, пока появится живой reader)
важно: если на этом этапе останется жив предыдущий reader, то этот момент пройдётся с ним, а после
этого он сразу умрёт и будет deadlock
во избежание данного казаксуса в этом месте делаем ещё одну проверку с semtimedop-ами с каждой стороны
(семафоры называется как-нибудь criticalGuard): просим в reader-e writer-a поднять семафор и наоборот
    4) С этого момента начинается передача: в ней участвуют 2 семафора - full и empty
        P (empty, 1)
        checkReaderready ()
        write ()
        V (full, 1)
    если writer сдохнет во время передачи, full никто не поднимет и reader повиснет
    во избежание этого до начала передачи делаем ++full без SEM_UNDO и --full с SEM_UNDO
    тогда при смерти writer-а V (full, 1) произойдёт автоматически



READER:
    1) Рождаемся, обращаемся к set-y семафоров (создаем если ещё не создан)
    2) Сначала ждём пока busy не будет == 0, 
    затем повышение семафора busy на 1 SEM_UNDO, и readyReader на 1 (в противоп порядке)
теперь если у нас создастся новый reader, то он будет ожидать на этом моменте окончания 
работы предыдущей пары
    3) Делаем P (1) на семафоре readyWriter (ждём, пока появится живой writer)
В этом месте проверка с semtimedop-ами
    4) С этого момента начинается передача: в ней участвуют 2 семафора - full и empty
        P (full, 1)
        read ()
        checkWriterready ()
        V (empty, 1)
    если reader сдохнет во время передачи, empty никто не поднимет и writer повиснет
    во избежание этого до начала передачи делаем ++empty без SEM_UNDO и --empty с SEM_UNDO
    а ещё empty надо поднять на 1 чтобы writer смог его опустить при начале передачи
    тогда при смерти reader-а V (empty, 1) произойдёт автоматически

Доп идеи:

1) SHMEM должен создаваться writer-ом и удаляться им же, поскольку только reader-ом он не 
используется, а значит и не нужен ему

2) Нам нужно как-то понять, успел writer записать что-то до смерти или нет. Для этого в памяти
делаем отдельную ячейку с ядом. После записи в разделяемую память writer считывает следующую
часть буфера, и если возвращается 0, то в эту ячейку помещаем флаг конца передачи. Если же
прочиталось какое то количество символов, то пишем в эту ячейку флаг продолжения передачи.
Перед прочтением разделяемой памяти, reader смотрит в значение этой ячейки, а затем сразу же 
сбрасывает её в яд. Таким образом, если writer убьют до установки флага, мы сразу об этом узнаем.

А теперь всё то же самое, только дополнительно храним size прочитанных символов из файла (чтобы 
не выводить лишнего в stdout)

одна из идей которые на первый взгляд кажутся сумасшедшими: каждый раз после окончания работы reader-a 
(понижении семафора busy) делать RMID всех семафоров, при этом в начале writer-a делать соотв. обработчик:
если семафоров нет, то их только что удалили, значит надо еще раз создать

была ошибка из-за shmctl, поэтому коротко опишу как он работает
при вызове shmctl RMID память не удаляется до тех пор, пока к ней подключен еще хотя бы 1 процесс
НО подключение новых процессов к ней уже будет невозможно (под подключением подразумеваю shmat)