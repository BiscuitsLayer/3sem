A child process created via fork(2) inherits its parent's  umask.   The
       umask is left unchanged by execve(2).

write() writes !!!up to count bytes!!! from the buffer starting at buf to the
       file referred to by the file descriptor fd.

A process can open a FIFO in nonblocking mode.  In this case, opening for
       read-only  succeeds  even  if no one has opened on the write side yet and
       opening for write-only fails with  ENXIO  (no  such  device  or  address)
       unless the other end has already been opened.

When  a  process  tries to write to a FIFO that is not opened for read on
       the other side, the process is sent a SIGPIPE signal.

If  all  file  descriptors referring to the write end of a pipe have been
       closed, then an attempt to read(2) from the  pipe  will  see  end-of-file
       (read(2)  will  return 0).  If all file descriptors referring to the read
       end of a pipe have been closed, then a write(2) will cause a SIGPIPE sig‐
       nal  to  be generated for the calling process.  If the calling process is
       ignoring this signal, then write(2)  fails  with  the  error  EPIPE. 

       https://it.wikireading.ru/1029 очень полезно

       https://stackoverflow.com/questions/7931811/detect-when-a-fifo-is-opened-from-a-program

---------------------------------------------------
Размер PIPE-a (PIPE_SIZE) = 16 * PIPE_BUF !!! то есть целиком 
       заполнить PIPE за один раз не выйдет
---------------------------------------------------

Пусть у нас один FIFO
1) Если открыть оба в NON_BLOCK режиме, то при sleep-e writer-а труба может опустеть, и тогда
       read сразу же вернёт -1 <- это плохо, тк непонятно из-за чего вернулся -1: то ли отключился
       writer (kill -signal SIGKILL), то ли он просто стоит на паузе.

       !!! ЗНАЧИТ НУЖНО СДЕЛАТЬ ЗАПРОС К WRITER-у, И ЕСЛИ ОН НЕ ОТВЕТИТ
              ПРЕКРАТИТЬ ПЕРЕДАЧУ !!!
              
2) Если reader открыт без NON_BLOCK режима, то предыдущей проблемы не будет, но зато при SIGKILL-e 
       writer-a reader окажется в deadlock-e. 

       !!! ЗНАЧИТ READER НАДО С NON_BLOCK-ом !!!

3) Ещё одно преимущество в копилку NON_BLOCK-a: пусть мы пишем в FIFO сообщениями размером
       PIPE_BUF * 16, тогда при отсутствии NON_BLOCK writer будет ждать, пока освободится место, 
       а значит если убить в этот момент reader, то возникнет deadlock.

---------------------------------------------------
Алгоритм
Каждый reader создаёт своб трубу channel <- она будет использована
       для передачи основной информации. Каждый writer создаёт свою
       трубу service, через которую они будут коннектиться до начала
       передачи информации.
reader ищет в папке service трубы и пишет (СМ ДИЛЕММУ НИЖЕ) в одну
       либо во все трубы свой pid для коннекта с writer-ом. writer читает
       этот pid из своей service трубы и ищет в папке файл с именем
       channel_pid.fifo, соозданный как раз reader-ом, передавшим pid, а
       затем коннектится к нему и менять права доступа на 0000.
В чём преимущества и где дыры в этом решении?
       Преимущство, очевидно, в том что никогда не возникнет проблемы
       двойного readera На channel трубе, поскольку reader-ы и трубы
       жёстко связаны своими pid-ами. Однако, проблема двойного writer-a всё
       таки может возникнуть, и тут мы получаем дилемму:
              если писать каждым reader-ом только в один service FIFO,
                     то если после получения сообщения writer сразу вырубить,
                     то reader будет бесконечно долго ждать пока кто то 
                     подключится к его трубе
              эту проблему можно решить, если понять что делать с 
                     zombie-writer-ами (то есть они должны либо что то возвращать
                     либо гарантированно удалять свой service_pid.fifo, чтобы
                     reader смог понять что FIFO, в который он кинул запрос, 
                     удалился, а значит умер процесс, а значит нужно попробовать 
                     кинуть запрос в какой-нибудь другой FIFO)
              если же писать каждым reader-ом во все service FIFO, а потом ожидать
                     подключения и сразу блокироваться после него, то ВОТ ТУТ 
                     как раз и может возникнуть проблема двойного-writer-a:
                     к channel трубе этого reader-a подключится сначала один writer
                     он соберётся сменить права доступа к трубе нооооо
                     в это время подключается второй writer
                     права доступа успешно (хехе) меняются и мы получаем
                     chennel трубу с двумя writer-ами
              я пока не придумал как можно решить эту проблему, но мне кажется, что
                     после коннекта-с channel трубой writer может отправить по ней
                     reader-у свой pid, после чего writer снова отключится от 
                     channel трубы (АААА МОЗГ) и они будут коннектится с самого начала,
                     только теперь уже reader будет знать pid writer-а, а
                     значит будет писать только в одну конкретную трубу.
                     За 5 секунд размышлений я придумал у этого подхода уже два 
                     явных недостатка: 1) если после обмена pid-ами убить writer и 
                     останется его service_pid.fifo, то как следует поступить reader-у:
                     бесконечно ожидать? конечно нет, но это приводит нас ко второй проблеме
                     2) если он после этого будет кидать ещё заявки в другие трубы, то
                     предположим, что в этом случае writer не умрёт. Тогда опять получим
                     проблему двойного writer-a у channel трубы аналогичным образом.
                     Надо ещё думать.
---------------------------------------------------